My Journey in Learning COBOL 
===============================
A Portfolio of Maurolepis Dreki 
-------------------------------
V2021.275 

### Why Learn COBOL?
The short answer is *because I'm **not** a Web Developer*; a self explanitory 
answer to those who have been in the job market for Software Developemnt since 
the turn of the Centrury.

#### The Long Answer
I have always had a facination with mechanics and procedures, and aptitude that
doubtlessly goes back to the foundations of my existance, long before I was 
born.  Early in life, I had a cousin whom I associated with who had the 
whimiscal childhood notion of becoming a Game Developer, and an uncle who was
a Application Developer, and one day my cousin asked my uncle where to begin
his journey and, as his shaddow, so did I, and thus began my journey into 
Software Development.

But this shadowing was not enough to make me pursue Software Development as I
have over the last two decades; I have always been overshadowed by poverty, 
never had the luxury of having the right tools to do the jobs that I set out to
do, and it was no different in learning to code; programming seemed to be the 
way to close the gap, to fix the gaping holes other developers left in their 
features which made my life difficult; and the problem has expanded 
exponentially since then, rather than diminishing, to such a degree that these
programmers refuse to take responsibility for thier own publications, for they 
no longer look at a bug and have the odacity to call it a feature, now they 
look at it and say "it isn't mine" despite all impirical evidence to the 
contrary.

I learned programming in such a way that "the hard way" looks like a cakewalk:
I started by hyjacking my parrents dialup internet to download the ShrapDevelop
IDE to my personal, unnetworked, computer because there where no other options 
for me to aquire a C# compiler in those early days when monolithic installers 
where starting to be replaced with network installers, and then proceeded to 
learn by reading O'Reilly's *Programming C#*, 4<sup>th</sup> Edition, and using
SharpDevelop's AutoComplete feature to discover new instructions, -- I owe a
lot to that program for my early success in software, a success that has been 
both a blessing and a curse in my adventures since. -- I took my first formal
courswork some years later which pushed me into the wonderful world of trivial
Algorithms, specificaly the Bubble Sort and Binary Search, and caused me for 
the first time to expand my horrizons beyond business logic.

Entering college, I was compelled to learn C++, the language that I would come
to consider more native to me than English, and had imprinted upon my mind by 
a classmate that using GUI builders such as in Visual Studio and Glade where 
cheating because the underlying code is generated for you by these tools.  And
it wasn't long after that I abandoned IDEs altogether.

I quickly droped out of the formal education system and returned to self 
education, a system I consider infinitely better due to it's focusing on what
you know as opposed to how much time you spend in the classroom and giving 
more value to deadlines than ensuring a student's skill in the subject of 
study.  I despise that system, but after years in the workforce I have come to 
realized that the problem is like a self-fulfilling prophecy: the education 
systems teach by this method because that is what the workforce is like, and
the workforce is like that because they where never taught any other way.

Because of my history, I have come to understand that innovation without 
philosophy is a curse.  And because of my history, my philosophy is first to 
the equality of the each member of the human species as fellow travelers to the
grave, second that anything worth doing in life is worth doing right the first 
time, and whenever it is not done right it must immediatly be done again, and 
third is that perfection is a noble pursuit that (computationaly) can be 
quantified as the optimal/minimal number of resouces used (processor operations,
memory, &c.) to achieve the corrct result continuously.  It is for this reason 
that I prefer C/C++ as a language as it (in it's Purest form), provides every 
oportunity for perfection, is not proprietary, and forces the coder to know 
what they are doing by allowing the programer to fail epically.

##### What does that have to do with COBOL?
To say that a person is more than the sum of their experieances is a lie: our 
experiances make us who we are, our circumstances the exclusive result of where
we have been, and even our philosophies and visions of the future are formed by
their accumulation; Pierre-Simon, marquis de Laplace, (1749-1827) believed that
everything in the universe in predictable on mathmatical equations, and Game 
Theory is (partialy) the realization of that belief regarding the psycology of 
living things.  Thus it is that my history and philosophies define the kind of 
programmer I am and want to be, and that kind of programmer does not prioritize
asthetic appeal over functionality, focuses on computational efficiancy as a 
key part of the user experiance, writes real computer code rather than just 
stitching modules together with configuration files, and is not afraid of 
getting their hands dirty by creating the right tool for a job over hacking 
around the wrong one.

The COBOL language predates C by many years, from a time when efficiency was 
not a philosophy so much as a nessesity, and as such it is often considered 
dead or obsolite.  But there is still legacy written in this language, 
regardless of popular oppinions against it's use, and much of that legacy is 
ritten with efficiency in mind as promoted by the nature of that language. 
And this is the kind of code I would like to write (in C/C++), so I can think
of no better language to learn than COBOL which will not only put me into the
sector of the programming industry I desire to be in, but also ensure there is
work available for me *because* I know this language that nobody else wants to
learn because it is "dead".

Despite anything I have ever done or will ever do, *I am **not** a Web 
Developer!*  I find the tools of Web Development restrictive and clunky, 
especialy REST which treats every request as a new and individual request and 
thus is unable to provide (in my oppinion) adiquite security or similar 
features that require a persistent or stateful connection.  But in this way of
thinking, I am in an increasing minority such that there are fewer and fewer 
opportunities available to programmers like me, and so having uncommon skills,
like COBOL, keeps me competitive in the industry.
